package forwardcache

import (
	"bytes"
	"github.com/thematthopkins/elm-protobuf/pkg/parsepb"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"

	"text/template"
)

func Generate(inFile *descriptorpb.FileDescriptorProto, messages []parsepb.PbMessage) (*pluginpb.CodeGeneratorResponse_File, error) {
	t := template.New("t")

	t, err := t.Parse(`module ForwardNew.Interface.Cache exposing (..)

-- DO NOT EDIT
-- AUTOGENERATED BY THE ELM PROTOCOL BUFFER COMPILER
-- https://github.com/tiziano88/elm-protobuf
-- source file: {{ .SourceFile }}

import ForwardNew.CacheKey exposing (CacheKey, cacheKey)
import ForwardNew.EntrypointCache as EntrypointCache exposing (EntrypointCache)
import Ids
import Pb

type alias Cache = { {{ range $index, $element := .CacheDefs}}
	{{if $index}},{{end}} {{if $element.IsList }} list_ids{{$element.UpperName}} : EntrypointCache (List Ids.{{$element.UpperName}}) {{else}} {{$element.LowerName}} : EntrypointCache Pb.{{$element.UpperName}} {{end}} {{end}}
}

empty : Cache
empty = { {{ range $index, $element := .CacheDefs}}
	{{if $index}},{{end}} {{if $element.IsList }}list_ids{{$element.UpperName}}{{else}}{{$element.LowerName}}{{end}} = EntrypointCache.empty {{end}}
}

{{ range .CacheDefs}}
{{if .IsList }}
list_ids{{.UpperName}} : CacheKey Cache (List Ids.{{.UpperName}})
list_ids{{.UpperName}} =
    cacheKey .list_ids{{.UpperName}} (\e c -> { c | list_ids{{.UpperName}} = e })
{{else}}
{{.LowerName}} : CacheKey Cache Pb.{{.UpperName}}
{{.LowerName}} =
    cacheKey .{{.LowerName}} (\e c -> { c | {{.LowerName}} = e })
{{end}}
{{end}}
`)
	if err != nil {
		return nil, err
	}

	messages_with_ids := parsepb.MessagesWithIds(messages)

	cacheDefs := []CacheDef{}
	for _, m := range messages_with_ids {
		cacheDefs = append(cacheDefs, CacheDef{
			UpperName: (string)(m.TypeAlias.Name),
			LowerName: m.TypeAlias.LowerName,
			IsList:    false,
		})
	}

	for _, m := range messages_with_ids {
		cacheDefs = append(cacheDefs, CacheDef{
			UpperName: (string)(m.TypeAlias.Name),
			LowerName: m.TypeAlias.LowerName,
			IsList:    true,
		})
	}

	buff := &bytes.Buffer{}
	if err = t.Execute(buff, struct {
		SourceFile string
		CacheDefs  []CacheDef
	}{
		SourceFile: inFile.GetName(),
		CacheDefs:  cacheDefs,
	}); err != nil {
		return nil, err
	}

	fileName := "ForwardNew/Interface/Cache.elm"
	result := buff.String()
	return &pluginpb.CodeGeneratorResponse_File{
		Name:    &fileName,
		Content: &result,
	}, nil
}

type CacheDef struct {
	LowerName string
	UpperName string
	IsList    bool
}
