package forwardcache

import (
	"bytes"
	"github.com/thematthopkins/elm-protobuf/pkg/elmpb"
	"github.com/thematthopkins/elm-protobuf/pkg/parsepb"
	"github.com/thematthopkins/elm-protobuf/pkg/stringextras"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
	"sort"
	"strings"

	"text/template"
)

func Generate(inFile *descriptorpb.FileDescriptorProto, messages []parsepb.PbMessage) (*pluginpb.CodeGeneratorResponse_File, error) {
	t := template.New("t")

	t, err := t.Parse(`module ForwardNew.Interface.Cache exposing (..)

-- DO NOT EDIT
-- AUTOGENERATED BY THE ELM PROTOCOL BUFFER COMPILER
-- https://github.com/tiziano88/elm-protobuf
-- source file: {{ .SourceFile }}

import ForwardNew.CacheKey exposing (CacheKey, cacheKey)
import ForwardNew.EntrypointCache as EntrypointCache exposing (EntrypointCache)
import Ids
import {{.MainPackage}}

type alias Cache = { {{ range $index, $element := .CacheDefs}}
    {{if $index}},{{end}} {{if $element.IsList }} list_ids{{$element.UpperName}} : EntrypointCache (List Ids.{{$element.UpperName}}) {{else}} {{$element.LowerName}} : EntrypointCache Pb.{{$element.UpperName}} {{end}} {{end}}
    }

empty : Cache
empty = { {{ range $index, $element := .CacheDefs}}
    {{if $index}},{{end}} {{if $element.IsList }}list_ids{{$element.UpperName}}{{else}}{{$element.LowerName}}{{end}} = EntrypointCache.empty {{end}}
    }

{{ range .CacheDefs}}
{{if .IsList }}
list_ids{{.UpperName}} : CacheKey Cache (List Ids.{{.UpperName}})
list_ids{{.UpperName}} =
    cacheKey .list_ids{{.UpperName}} (\e c -> { c | list_ids{{.UpperName}} = e })
{{else}}
{{.LowerName}} : CacheKey Cache Pb.{{.UpperName}}
{{.LowerName}} =
    cacheKey .{{.LowerName}} (\e c -> { c | {{.LowerName}} = e })
{{end}}
{{end}}
`)
	if err != nil {
		return nil, err
	}

	cacheDefs := []CacheDef{}
	singletons := parsepb.MessagesWithSingletons(messages)
	for _, m := range singletons {
		cacheDefs = append(cacheDefs, CacheDef{
			UpperName: (string)(m.TypeAlias.Name),
			LowerName: m.TypeAlias.LowerName,
			IsList:    false,
		})
	}

	messages_with_ids := parsepb.MessagesWithIds(messages)

	for _, m := range messages_with_ids {
		cacheDefs = append(cacheDefs, CacheDef{
			UpperName: (string)(m.TypeAlias.Name),
			LowerName: m.TypeAlias.LowerName,
			IsList:    false,
		})
	}

	messages_by_ids := map[string]struct{}{}

	for _, m := range messages_with_ids {
		for _, f := range m.TypeAlias.Fields {
			if f.Name == "id" {
				messages_by_ids[(string)(f.Type)] = struct{}{}
			}
		}
	}

	unique_messages_by_ids := []string{}
	for n := range messages_by_ids {
		unique_messages_by_ids = append(unique_messages_by_ids, n)
	}

	sort.Strings(unique_messages_by_ids)

	for _, s := range unique_messages_by_ids {
		idType := s
		if strings.HasPrefix(idType, "Ids.") {
			idType = strings.TrimPrefix(idType, "Ids.")
		}
		cacheDefs = append(cacheDefs, CacheDef{
			UpperName: idType,
			LowerName: stringextras.LowerCamelCase(idType),
			IsList:    true,
		})
	}
	mainPackage := elmpb.PackageName(inFile)

	buff := &bytes.Buffer{}
	if err = t.Execute(buff, struct {
		SourceFile  string
		MainPackage string
		CacheDefs   []CacheDef
	}{
		SourceFile:  inFile.GetName(),
		MainPackage: mainPackage,
		CacheDefs:   cacheDefs,
	}); err != nil {
		return nil, err
	}

	fileName := "ForwardNew/Interface/Cache.elm"
	result := buff.String()
	return &pluginpb.CodeGeneratorResponse_File{
		Name:    &fileName,
		Content: &result,
	}, nil
}

type CacheDef struct {
	LowerName string
	UpperName string
	IsList    bool
}
