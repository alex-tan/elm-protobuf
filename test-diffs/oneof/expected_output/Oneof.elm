module Oneof exposing (..)

-- DO NOT EDIT
-- AUTOGENERATED BY THE ELM PROTOCOL BUFFER COMPILER
-- https://github.com/tiziano88/elm-protobuf
-- source file: oneof.proto

import Protobuf exposing (..)

import Json.Decode as JD
import Json.Encode as JE


uselessDeclarationToPreventErrorDueToEmptyOutputFile = 42


type alias Foo =
    { firstOneof : Foo_FirstOneof
    , secondOneof : Foo_SecondOneof
    , syntheticOneof : Maybe String
    , syntheticOneofInnerMessage : Maybe InnerMessage
    }


fooDecoder : JD.Decoder Foo
fooDecoder =
    JD.lazy <| \_ -> decode Foo
        |> field foo_FirstOneofDecoder
        |> field foo_SecondOneofDecoder
        |> optional "syntheticOneof" JD.string
        |> optional "syntheticOneofInnerMessage" innerMessageDecoder


fooEncoder : Foo -> JE.Value
fooEncoder v =
    JE.object <| List.filterMap identity <|
        [ (foo_FirstOneofEncoder v.firstOneof)
        , (foo_SecondOneofEncoder v.secondOneof)
        , (optionalEncoder "syntheticOneof" JE.string v.syntheticOneof)
        , (optionalEncoder "syntheticOneofInnerMessage" innerMessageEncoder v.syntheticOneofInnerMessage)
        ]


type Foo_FirstOneof
    = 
     Foo_FirstOneof_StringField String
    | Foo_FirstOneof_IntField Int


foo_FirstOneofDecoder : JD.Decoder Foo_FirstOneof
foo_FirstOneofDecoder =
    JD.lazy <| \_ -> JD.oneOf
        [ JD.map Foo_FirstOneof_StringField (JD.field "stringField" JD.string)
        , JD.map Foo_FirstOneof_IntField (JD.field "intField" intDecoder)
        , JD.fail "Foo_FirstOneof_Unspecified"
        ]


foo_FirstOneofEncoder : Foo_FirstOneof -> Maybe ( String, JE.Value )
foo_FirstOneofEncoder v =
    case v of

        Foo_FirstOneof_StringField x ->
            Just ( "stringField", JE.string x )

        Foo_FirstOneof_IntField x ->
            Just ( "intField", JE.int x )


type Foo_SecondOneof
    = 
     Foo_SecondOneof_BoolField Bool
    | Foo_SecondOneof_OtherStringField String


foo_SecondOneofDecoder : JD.Decoder Foo_SecondOneof
foo_SecondOneofDecoder =
    JD.lazy <| \_ -> JD.oneOf
        [ JD.map Foo_SecondOneof_BoolField (JD.field "boolField" JD.bool)
        , JD.map Foo_SecondOneof_OtherStringField (JD.field "otherStringField" JD.string)
        , JD.fail "Foo_SecondOneof_Unspecified"
        ]


foo_SecondOneofEncoder : Foo_SecondOneof -> Maybe ( String, JE.Value )
foo_SecondOneofEncoder v =
    case v of

        Foo_SecondOneof_BoolField x ->
            Just ( "boolField", JE.bool x )

        Foo_SecondOneof_OtherStringField x ->
            Just ( "otherStringField", JE.string x )


type alias InnerMessage =
    { innerMessageVal : String -- 1
    }


innerMessageDecoder : JD.Decoder InnerMessage
innerMessageDecoder =
    JD.lazy <| \_ -> decode InnerMessage
        |> required "innerMessageVal" JD.string ""


innerMessageEncoder : InnerMessage -> JE.Value
innerMessageEncoder v =
    JE.object <| List.filterMap identity <|
        [ (requiredFieldEncoder "innerMessageVal" JE.string "" v.innerMessageVal)
        ]


type alias Foo2 =
    { firstOneof : Foo2_FirstOneof
    }


foo2Decoder : JD.Decoder Foo2
foo2Decoder =
    JD.lazy <| \_ -> decode Foo2
        |> field foo2_FirstOneofDecoder


foo2Encoder : Foo2 -> JE.Value
foo2Encoder v =
    JE.object <| List.filterMap identity <|
        [ (foo2_FirstOneofEncoder v.firstOneof)
        ]


type Foo2_FirstOneof
    = 
     Foo2_FirstOneof_StringField String
    | Foo2_FirstOneof_IntField Int


foo2_FirstOneofDecoder : JD.Decoder Foo2_FirstOneof
foo2_FirstOneofDecoder =
    JD.lazy <| \_ -> JD.oneOf
        [ JD.map Foo2_FirstOneof_StringField (JD.field "stringField" JD.string)
        , JD.map Foo2_FirstOneof_IntField (JD.field "intField" intDecoder)
        , JD.fail "Foo2_FirstOneof_Unspecified"
        ]


foo2_FirstOneofEncoder : Foo2_FirstOneof -> Maybe ( String, JE.Value )
foo2_FirstOneofEncoder v =
    case v of

        Foo2_FirstOneof_StringField x ->
            Just ( "stringField", JE.string x )

        Foo2_FirstOneof_IntField x ->
            Just ( "intField", JE.int x )
